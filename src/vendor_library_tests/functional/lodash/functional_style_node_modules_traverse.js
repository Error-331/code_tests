// external imports
const {join, basename} = require('path');
const {constants, statSync, readdirSync, accessSync} = require('fs');

const {constant, complement, stubTrue, eq, cond, curry, map, pipe, concat, contains} = require('lodash/fp');

// constants definition
const SPECIAL_DIRECTORY_NAMES = ['.', '..'];
const SPECIFIC_DIRECTORIES_TO_EXCLUDE = ['.bin', '@babel'];

const DIRECTORIES_TO_EXCLUDE = concat(SPECIAL_DIRECTORY_NAMES, SPECIFIC_DIRECTORIES_TO_EXCLUDE);

// functions definition

/**
 * Checks whether provided value belongs to exclusions list.
 *
 */

const isExclusion = curry((exclusions, value) => contains(value, exclusions));

/**
 * Checks whether directory belongs to exclusion list.
 *
 */

const isExclusionDirPath = path => isExclusion(DIRECTORIES_TO_EXCLUDE, basename(path));

const isEntityHasAccess = curry((accessType, entity) => {
    try {
        accessSync(entity, accessType);
        return true;
    } catch(error) {
        return false;
    }
});

const isEntityExists = isEntityHasAccess(constants.F_OK);

const isEntityReadable = isEntityHasAccess(constants.R_OK);

const isEntityNotExists = complement(isEntityExists);

const isEntityNotReadable = complement(isEntityReadable);

const isDirectory = path => statSync(path).isDirectory();

const isNotDirectory = path => eq(false, isDirectory(path));

const joinTwoPaths = curry((path1, path2) => join(path1, path2));

const traverseDirectory = curry((callBack, rootDirPath) => {
    return map(
        pipe(joinTwoPaths(rootDirPath), callBack),
        readdirSync(rootDirPath)
    );
});


const traverseDirectoryRecursive = curry((callBack, filterFunc, pathTransformFunc, dirPath) => {
    const recursiveCallback = traverseDirectoryRecursive(callBack, filterFunc, pathTransformFunc);
    const preparedDirPath = pathTransformFunc(dirPath);

    return cond([
        [isEntityNotExists, constant(null)],
        [isEntityNotReadable, constant(null)],
        [isNotDirectory, constant(null)],
        [filterFunc(dirPath), constant(null)],
        [stubTrue, traverseDirectory(recursiveCallback)]
    ])(preparedDirPath);
});

const logDirectory =  curry((logPrefix, directoryPath) => {
    console.log(`${logPrefix}${directoryPath}`);
    return directoryPath;
});

// module implementation
const pathToRootNodeModules = '/home/segei/projects/code_tests';

const addNodeModulesDir = path => join(path, '/node_modules');



const nodeModulesTreeFilter = curry((path, transformedPath) => {
    const originalPathFilter = cond([
        [isExclusionDirPath, constant(true)],
        [stubTrue, constant(false)],
    ])(path);

    const transformedPathFilter = cond([
        [stubTrue, constant(false)],
    ])(transformedPath);

    return originalPathFilter || transformedPathFilter;
});

traverseDirectoryRecursive(
    pipe(logDirectory('Directory: ')),
    nodeModulesTreeFilter,
    addNodeModulesDir,
    pathToRootNodeModules,
);
