'use strict';

// external imports
const {join} = require('path');



const {isNil, stubTrue, cond, constant, curry} = require('lodash/fp');

// local imports
const {DIRECTORIES_TO_EXCLUDE} = require('./constants/exclusion_constants');

const {isExclusion} = require('./helpers/validation_helpers');
const {joinTwoPaths, removeLastPathEntity} = require('./helpers/path_helpers');
const {generateSync} = require('./helpers/promise_sync_helpers');

const {insertNewPath} = require('./db/sqlite/paths_traversed_query_wrappers');

const {setJSMemoryDBType, setSQLiteDBType} = require('./effects/app_effects');
const {prepareDatabase, isPathAlreadyTraversed, insertModuleData, insertDependencyListToDB} = require('./effects/db_effects');
const {readPackageJSON, traverseDirectoryRecursive, traverseNodeModulesDirectory} = require('./effects/fs_effects');

// functions definition


const logDirectory =  curry((logPrefix, directoryPath) => {
    console.log(`${logPrefix}${directoryPath}`);
    return directoryPath;
});

// module implementation
//const pathToRootNodeModules = '/home/segei/projects/code_tests';
//const pathToRootNodeModules = '/home/segei/Downloads';
const pathToRootNodeModules = '/home/brightsign/projects/fatback/';
//const pathToRootNodeModules = '/home/brightsign/projects/fatback/bsCore';
// const pathToRootNodeModules = '/home/brightsign/projects/fatback/node_modules/bacon/node_modules/@brightsign/ba-dialog-ui/node_modules/@brightsign/ba-context-model/node_modules/@brightsign/bs-playlist-dm/node_modules/@brightsign/bscore/';

const addNodeModulesDir = path => join(path, '/node_modules');

const nodeModulesTreeFilter = curry((path, transformedPath) => {
    const originalPathFilter = cond([
        [isExclusionDirPath, constant(true)],
        [stubTrue, constant(false)],
    ])(path);

    const transformedPathFilter = cond([
        [stubTrue, constant(false)],
    ])(transformedPath);

    return originalPathFilter || transformedPathFilter;
});

const userCallback = curry((dbConnection, originalPath, pathToParentNodeModules, packageDirName, installedChildNodeModules) => {
    return generateSync(function* () {
        // compose full path to module
        const pathToModule = joinTwoPaths(pathToParentNodeModules, packageDirName);

        //console.log(chalk.green(`Processing package in '${pathToModule}'`));

        // apply filter to directory name
        if (isExclusion(DIRECTORIES_TO_EXCLUDE, packageDirName)) {
            return;
        }

        // read package.json
        const currentPackageJSON = readPackageJSON(pathToModule);

        // extract name and version of the current module
        const {name, version} = currentPackageJSON;

        // insert current module data to DB
        const currentModuleLocationID = yield insertModuleData(dbConnection, name, version, pathToModule, null);

        if (isNil(currentModuleLocationID)) {
            yield null;
            return;
        }

        // extract module dependencies lists
        let {dependencies, devDependencies, peerDependencies} = currentPackageJSON;

        // insert dependencies data from package.json into DB
        yield insertDependencyListToDB(dbConnection, dependencies, pathToModule, currentModuleLocationID, 'dependency');
        yield insertDependencyListToDB(dbConnection, devDependencies, pathToModule, currentModuleLocationID, 'devDependencies');
        yield insertDependencyListToDB(dbConnection, peerDependencies, pathToModule, currentModuleLocationID, 'peerDependencies');

        yield packageDirName;
    })();
});

setSQLiteDBType();

const b = generateSync(function* () {
    console.log('Open DB connection...');
    const dbConnection = yield openConnectionToDB();

    yield prepareDatabase(dbConnection);

    //
    yield userCallback(dbConnection, '', pathToRootNodeModules, '', []);

    const result = yield traverseDirectoryRecursive(
        userCallback(dbConnection),
        traverseNodeModulesDirectory,

        generateSync(function* (path) {
            const isPathVisited = yield isPathAlreadyTraversed(dbConnection, path);

            if (isPathVisited === false) {
                let preparedPath = removeLastPathEntity(path);
                yield insertNewPath(dbConnection, preparedPath);
            }

            yield isPathVisited;
        }),

        addNodeModulesDir,
        pathToRootNodeModules,
    );

    console.log('Closing DB connection...');
    yield closeConnectionToDB(dbConnection);
});

b();

