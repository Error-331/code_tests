// external imports
const {join, basename} = require('path');
const {constants, statSync, readdirSync, accessSync} = require('fs');

const semver = require('semver');
const jsonfile = require('jsonfile')
const {stubTrue, eq, cond, constant, identity, complement, defaultTo, curry, map, reduce, concat, filter, contains} = require('lodash/fp');

// constants definition
const SPECIAL_DIRECTORY_NAMES = ['.', '..'];
const SPECIFIC_DIRECTORIES_TO_EXCLUDE = ['.bin', '@babel'];

const DIRECTORIES_TO_EXCLUDE = concat(SPECIAL_DIRECTORY_NAMES, SPECIFIC_DIRECTORIES_TO_EXCLUDE);

// functions definition

/**
 * Checks whether provided value belongs to exclusions list.
 *
 */

const isExclusion = curry((exclusions, value) => contains(value, exclusions));

const isNotExclusion =  curry((exclusions, value) => !contains(value, exclusions));

/**
 * Checks whether directory belongs to exclusion list.
 *
 */

const isExclusionDirPath = path => isExclusion(DIRECTORIES_TO_EXCLUDE, basename(path));

const isNPMOrganizationDir = dirName => dirName[0] === '@';

const isNoneNPMOrganizationDir = complement(isNPMOrganizationDir);

const isEntityHasAccess = curry((accessType, entity) => {
    try {
        accessSync(entity, accessType);
        return true;
    } catch(error) {
        return false;
    }
});

const isEntityExists = isEntityHasAccess(constants.F_OK);

const isEntityReadable = isEntityHasAccess(constants.R_OK);

const isEntityNotExists = complement(isEntityExists);

const isEntityNotReadable = complement(isEntityReadable);

const isDirectory = path => statSync(path).isDirectory();

const isNotDirectory = path => eq(false, isDirectory(path));

const joinTwoPaths = curry((path1, path2) => join(path1, path2));

const traverseDirectory = curry((mapCallback, filterFunc, rootDirPath) => {
    const fsEntities = readdirSync(rootDirPath);
    const filteredFSEntities = filter(filterFunc, fsEntities);

    return map(
        mapCallback,
        filteredFSEntities,
    );
});

const traverseNodeModulesDirectory = curry((mapCallback, filterFunc, rootDirPath) => {
    const fsEntities = readdirSync(rootDirPath);
    const filteredFSEntities = filter(filterFunc, fsEntities);

    const organizationDirs = filter(isNPMOrganizationDir, filteredFSEntities);
    const noneOrganizationDirs = filter(isNoneNPMOrganizationDir, filteredFSEntities);

    let combinedDirList = reduce((dirsList, dirName) => {
        return concat(dirsList, traverseDirectory(c => `${dirName}/${c}`, filterFunc, joinTwoPaths(rootDirPath, dirName)))
    }, noneOrganizationDirs, organizationDirs);

    return map(
        mapCallback,
        combinedDirList,
    );
});

const traverseDirectoryRecursive = curry((userCallback, traverseCallback, filterFunc, pathTransformFunc, dirPath) => {
    const preparedDirPath = pathTransformFunc(dirPath);
    const recursiveCallback = traverseDirectoryRecursive(userCallback, traverseCallback, filterFunc, pathTransformFunc);
    const mapCallback = dirName => userCallback(dirPath, transformedPath, dirName, recursiveCallback(joinTwoPaths(transformedPath, dirName)));

    const transformedPath = pathTransformFunc(dirPath);

    return cond([
        [isEntityNotExists, constant(null)],
        [isEntityNotReadable, constant(null)],
        [isNotDirectory, constant(null)],
        [stubTrue, () => traverseCallback(mapCallback, filterFunc, transformedPath)]
    ])(preparedDirPath);
});

const logDirectory =  curry((logPrefix, directoryPath) => {
    console.log(`${logPrefix}${directoryPath}`);
    return directoryPath;
});

// module implementation
//const pathToRootNodeModules = '/home/segei/projects/code_tests';
const pathToRootNodeModules = '/home/segei/Downloads';
//const pathToRootNodeModules = '/home/brightsign/projects/fatback/';

const addNodeModulesDir = path => join(path, '/node_modules');

const nodeModulesTreeFilter = curry((path, transformedPath) => {
    const originalPathFilter = cond([
        [isExclusionDirPath, constant(true)],
        [stubTrue, constant(false)],
    ])(path);

    const transformedPathFilter = cond([
        [stubTrue, constant(false)],
    ])(transformedPath);

    return originalPathFilter || transformedPathFilter;
});

const depMap = new Map();
const depDepMap = new Map();
const peerDepMap = new Map();

const saveDepsStat = curry((packageName, pathToPackage, dependencies, devDependencies, peerDependencies) => {
 // deps peer

const c = (dependencies, mapObj) => {
    for (let dependency in dependencies) {
        const dependencyVersion = dependencies[dependency];

        if (mapObj.has(dependency)) {
            mapObj.get(dependency).get('versions').add(dependencyVersion);

            if (!mapObj.get(dependency).get('packages').has(dependencyVersion)) {
                mapObj.get(dependency).get('packages').set(dependencyVersion, {packageName, pathToPackage});
            }

        } else {
            const b = new Map();
            b.set(dependencyVersion, {packageName, pathToPackage});

            const c = new Map();
            c.set('packages', b);
            c.set('versions', new Set([dependencyVersion]));

            mapObj.set(dependency, c)
        }
    }
}

c(dependencies, depMap);
c(devDependencies, depDepMap);
c(peerDependencies, peerDepMap);

});

const userCallback = curry((originalPath, transformedPath, packageDirName, installedChildNodeModules) => {
    const pathToPackage = join(transformedPath, packageDirName);
    const pathToPackageJSON = join(pathToPackage, 'package.json');

    if (isEntityNotExists(pathToPackageJSON)) {
        return null;
    }

    const packageJSON = require(pathToPackageJSON);

    const {name, version} = packageJSON;
    let {dependencies, devDependencies, peerDependencies,} = packageJSON;

    dependencies = defaultTo({})(dependencies);
    devDependencies = defaultTo({})(devDependencies);
    peerDependencies = defaultTo({})(peerDependencies);

    saveDepsStat(name, pathToPackage, dependencies, devDependencies, peerDependencies);

    return {
        name,
        version,
        path: pathToPackage,

        dependencies,
        devDependencies,
        peerDependencies,

        installedChildNodeModules,
    };
});

const result = traverseDirectoryRecursive(
    userCallback,
    traverseNodeModulesDirectory,
    isNotExclusion(DIRECTORIES_TO_EXCLUDE),
    addNodeModulesDir,
    pathToRootNodeModules,
);



jsonfile.writeFile('./deps_tree.json', result, { spaces: 2 }, function (err) {
    if (err) console.error(err)
});




let versions = [...peerDepMap.get('react').get('versions')];
//versions = ['14.0.0', '16.0.0']
//console.log(semver.maxSatisfying(versions, '<=15.0.0'));

console.log(peerDepMap);
