// external imports
const {join, basename} = require('path');
const {constants, statSync, readdirSync, accessSync} = require('fs');

const {isNil, eq, cond, constant, complement, stubTrue, curry, map, pipe, concat, filter, contains} = require('lodash/fp');

// constants definition
const SPECIAL_DIRECTORY_NAMES = ['.', '..'];
const SPECIFIC_DIRECTORIES_TO_EXCLUDE = ['.bin', '@babel'];

const DIRECTORIES_TO_EXCLUDE = concat(SPECIAL_DIRECTORY_NAMES, SPECIFIC_DIRECTORIES_TO_EXCLUDE);

// functions definition

/**
 * Checks whether provided value belongs to exclusions list.
 *
 */

const isExclusion = curry((exclusions, value) => contains(value, exclusions));

/**
 * Checks whether directory belongs to exclusion list.
 *
 */

const isExclusionDirPath = path => isExclusion(DIRECTORIES_TO_EXCLUDE, basename(path));


const isNotExclusion =  curry((exclusions, value) => !contains(value, exclusions));

const isEntityHasAccess = curry((accessType, entity) => {
    try {
        accessSync(entity, accessType);
        return true;
    } catch(error) {
        return false;
    }
});

const isEntityExists = isEntityHasAccess(constants.F_OK);

const isEntityReadable = isEntityHasAccess(constants.R_OK);

const isEntityNotExists = complement(isEntityExists);

const isEntityNotReadable = complement(isEntityReadable);

const isDirectory = path => statSync(path).isDirectory();

const isNotDirectory = path => eq(false, isDirectory(path));

const joinTwoPaths = curry((path1, path2) => join(path1, path2));

const traverseDirectory = curry((transformFunc, filterFunc,  rootDirPath) => {
    const fsEntities = readdirSync(rootDirPath);
    const filteredFSEntities = filter(filterFunc, fsEntities);

    return map(
        transformFunc,
        filteredFSEntities,
    );
});


const traverseDirectoryRecursive = curry((userCallback, filterFunc, pathTransformFunc, dirPath) => {




    const preparedDirPath = pathTransformFunc(dirPath);
    const recursiveCallback = traverseDirectoryRecursive(userCallback, filterFunc, pathTransformFunc);

    const preparedUserCallback = curry((originalPath, transformedPath) => {

        return traverseDirectory(

                s => {
                    return userCallback(originalPath, transformedPath, s, recursiveCallback(joinTwoPaths(transformedPath, s)))


                },

            filterFunc, // stubTrue - if no filtering needed
            transformedPath)
    });

    return cond([
        [isEntityNotExists, constant(null)],
        [isEntityNotReadable, constant(null)],
        [isNotDirectory, constant(null)],

        [stubTrue, preparedUserCallback(dirPath)]
    ])(preparedDirPath);
});

const logDirectory =  curry((logPrefix, directoryPath) => {
    console.log(`${logPrefix}${directoryPath}`);
    return directoryPath;
});

// module implementation
const pathToRootNodeModules = '/home/segei/projects/code_tests';

const addNodeModulesDir = path => join(path, '/node_modules');



const nodeModulesTreeFilter = curry((path, transformedPath) => {
    const originalPathFilter = cond([
        [isExclusionDirPath, constant(true)],
        [stubTrue, constant(false)],
    ])(path);

    const transformedPathFilter = cond([
        [stubTrue, constant(false)],
    ])(transformedPath);

    return originalPathFilter || transformedPathFilter;
});

const c = curry((originalPath, transformedPath, dirName, deps) => {



    return {
        moduleName: dirName,

        path: originalPath,
        nodeModulesPath: transformedPath,

        nodeModules: deps,
    }

    return deps;
});

const result = traverseDirectoryRecursive(
    c,

    //pipe(logDirectory('Directory: ')),
    isNotExclusion(DIRECTORIES_TO_EXCLUDE),
    addNodeModulesDir,
    pathToRootNodeModules,
);

console.log(result);