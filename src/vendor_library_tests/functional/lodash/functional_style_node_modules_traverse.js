'use strict';

// external imports
const {join, sep} = require('path');

const semver = require('semver');
const jsonfile = require('jsonfile');
const {stubTrue, cond, constant, defaultTo, curry, pipe} = require('lodash/fp');

const sqlite = require('sqlite');

// local imports
const {DIRECTORIES_TO_EXCLUDE} = require('./constants/exclusion_constants');

const {isExclusion, isEntityNotExists} = require('./helpers/validation_helpers');
const {traverseDirectoryRecursive, traverseNodeModulesDirectory} = require('./helpers/fs_traverse_helpers');

const {generateSync} = require('./helpers/promise_sync_helpers');

const {createModulesNamesTable, dropModulesNamesTable, insertNewModuleName} = require('./db/modules_names_query_wrappers');

// functions definition


const openConnectionToDB = () => sqlite.open('test.sqlite');
const closeConnectionToDB = (dbConnection) => dbConnection.close();



const visitedAbsolutePaths = new Set();
const visitedAbsoulteRealPaths = new Set();



const logDirectory =  curry((logPrefix, directoryPath) => {
    console.log(`${logPrefix}${directoryPath}`);
    return directoryPath;
});

// module implementation
const pathToRootNodeModules = '/home/segei/projects/code_tests';
//const pathToRootNodeModules = '/home/segei/Downloads';
//const pathToRootNodeModules = '/home/brightsign/projects/fatback/';
//const pathToRootNodeModules = '/home/brightsign/projects/fatback/';
// const pathToRootNodeModules = '/home/brightsign/projects/fatback/node_modules/bacon/node_modules/@brightsign/ba-dialog-ui/node_modules/@brightsign/ba-context-model/node_modules/@brightsign/bs-playlist-dm/node_modules/@brightsign/bscore/';

const addNodeModulesDir = path => join(path, '/node_modules');

const nodeModulesTreeFilter = curry((path, transformedPath) => {
    const originalPathFilter = cond([
        [isExclusionDirPath, constant(true)],
        [stubTrue, constant(false)],
    ])(path);

    const transformedPathFilter = cond([
        [stubTrue, constant(false)],
    ])(transformedPath);

    return originalPathFilter || transformedPathFilter;
});

const depMap = new Map();
const depDepMap = new Map();
const peerDepMap = new Map();

const saveDepsStat = curry((packageName, pathToPackage, dependencies, devDependencies, peerDependencies) => {
 // deps peer

const c = (dependencies, mapObj) => {
    for (let dependency in dependencies) {
        const dependencyVersion = dependencies[dependency];

        if (mapObj.has(dependency)) {
            mapObj.get(dependency).get('versions').add(dependencyVersion);

            if (!mapObj.get(dependency).get('packages').has(dependencyVersion)) {
                mapObj.get(dependency).get('packages').set(dependencyVersion, {packageName, pathToPackage});
            }

        } else {
            const b = new Map();
            b.set(dependencyVersion, {packageName, pathToPackage});

            const c = new Map();
            c.set('packages', b);
            c.set('versions', new Set([dependencyVersion]));

            mapObj.set(dependency, c);
        }
    }
}

c(dependencies, depMap);
c(devDependencies, depDepMap);
c(peerDependencies, peerDepMap);

});

const userCallback1 = curry((originalPath, transformedPath, packageDirName, installedChildNodeModules) => {
    console.log('---', originalPath, transformedPath, packageDirName);

    const pathToPackage = join(transformedPath, packageDirName);
    const pathToPackageJSON = join(pathToPackage, 'package.json');

    if (isEntityNotExists(pathToPackageJSON)) {
        return null;
    }

    const packageJSON = require(pathToPackageJSON);

    const {name, version} = packageJSON;
    let {dependencies, devDependencies, peerDependencies,} = packageJSON;

    dependencies = defaultTo({})(dependencies);
    devDependencies = defaultTo({})(devDependencies);
    peerDependencies = defaultTo({})(peerDependencies);

    saveDepsStat(name, pathToPackage, dependencies, devDependencies, peerDependencies);
return null;
    /*return {
        name,
        version,
        path: pathToPackage,

        dependencies,
        devDependencies,
        peerDependencies,

        installedChildNodeModules,
    };*/
});

const userCallback = curry((dbConnection, originalPath, transformedPath, packageDirName, installedChildNodeModules) => {
    return generateSync(function* () {
        const {lastID} = yield  insertNewModuleName(dbConnection, packageDirName, 0);
        console.log('id', lastID);
    })();
});



const b = generateSync(function* () {
    console.log('Open DB connection...');
    const dbConnection = yield openConnectionToDB();

    console.log('Dropping `modules_names` table...');
    yield dropModulesNamesTable(dbConnection);

    console.log('Creating `modules_names` table...');
    yield createModulesNamesTable(dbConnection);



    const result = yield traverseDirectoryRecursive(
        userCallback(dbConnection),
        traverseNodeModulesDirectory,
        pipe(path => {
            //console.log('filter');
            const c = path.split(sep);
///console.log('f', c[c.length - 2]);
            return c[c.length - 2];
        }, isExclusion(DIRECTORIES_TO_EXCLUDE), () => false),
        addNodeModulesDir,
        pathToRootNodeModules,
    );

    console.log('Closing DB connection...');
    yield closeConnectionToDB(dbConnection);
});

b();



/*jsonfile.writeFile('./deps_tree.json', result, { spaces: 2 }, function (err) {
    if (err) console.error(err)
});*/



//console.log(sqlite.open('test.sqlite'));

//let versions = [...peerDepMap.get('react').get('versions')];
//versions = ['14.0.0', '16.0.0']
//console.log(semver.maxSatisfying(versions, '<=15.0.0'));

//console.log(depMap);


/*




modules_connections

id
module_id
module_dependency_id
type (dev, peer, regular)


modules_versions

id
module_id
version

modules_locations

id
module_id
path


 */
